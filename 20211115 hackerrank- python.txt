
    PreparePythonIntroductionPython If-Else

Python If-Else


import math
import os
import random
import re
import sys
if __name__ == '__main__':
    n = int(input().strip())
    if n%2!=0 and n>=2 and n<=5:
        print('Weird')
    elif n%2==0 and n>=2 and n<=5:
        print('Not Weird')
    elif n%2==0 and n>=6 and n<=20:
        print('Weird')
    elif n>20:    
        print('Not Weird')
    else:
        print('error')


import math
import os
import random
import re
import sys
if __name__ == '__main__':
    n = int(input().strip())
    if n%2!=0 and n>=2 and n<=5:
        print('Weird')
    elif n%2==0 and n>=2 and n<=5:
        print('Not Weird')
    elif n%2==0 and n>=6 and n<=20:
        print('Weird')
    elif n>20:    
        print('Not Weird')
    else:
        print('')

import math
import os
import random
import re
import sys
if __name__ == '__main__':
    n = int(input().strip())
    if n%2!=0:
        print('Weird')
    elif n%2==0 and n>=2 and n<=5:
        print('Not Weird')
    elif n%2==0 and n>=6 and n<=20:
        print('Weird')
    elif n>20:    
        print('Not Weird')
    else:
        print('')

__________________

    PreparePythonIntroductionArithmetic Operators

Arithmetic Operators


if __name__ == '__main__':
    a = int(input())
    b = int(input())
    class Calculator:
        def __init__(self, n, m):
            self.n = n
            self.m = m
        def addition(self, n, m):
            add= n+m;
            return self.add
        def subtract(self, n, m):
            sub= n-m;
            return self.sub        
        def multiply(self, n, m):
            mul= n*m;
            return self.mul
    print(Calculator.addition(a, b));
    print(Calculator.subtract(a, b));
    print(Calculator.multiply(a, b));

Attempt at class based answer- failed. 


import math
import os
import random
import re
import sys
class Calculator:
    def __init__(self, n, m):
        self.n = n
        self.m = m
    def addition(self, n, m):
        add= n+m;
        return self.add
    def subtract(self, n, m):
        sub= n-m;
        return self.sub        
    def multiply(self, n, m):
        mul= n*m;
        return self.mul
if __name__ == '__main__':
    a = int(input())
    b = int(input())
    calc= Calculator(a,b);
    print(calc.addition(a, b));
    print(calc.subtract(a, b));
    print(calc.multiply(a, b));

My Answer-

if __name__ == '__main__':
    a = int(input())
    b = int(input())
    print(a+b);
    print(a-b);
    print(a*b);

Discussion answers interesting-

print(a+b,a-b,a*b, sep="\n")
    
tambah, tolak, darab = a+b, a-b, a*b
print(tambah)
print(tolak)
print(darab)


def fun(m,n):
    print(m+n,m-n,m*n,sep="\n")
    return
if __name__ == '__main__':
    a = int(input())
    b = int(input())
    fun(a,b)

a = int(input())
b = int(input())
def operaciones (a,b):
    suma = a+b
    print (suma)
    resta = a-b
    print (resta)
    multiplicacion = a*b
    print (multiplicacion)
operaciones (a,b)


def function(a, b):
    print(a+b)
    print(a-b)
    print(a*b)
a = int(raw_input())
b = int(raw_input())
function(a, b)

if __name__ == '__main__':
    a = int(input())
    b = int(input())
    print(a//b);
    print(a/b);
    /*
    if b== 0:
	print('error');
    else: 
	print(a/b);
        */
        
________________

    PreparePythonIntroductionLoops

Loops

My answer-

if __name__ == '__main__':
    n = int(input())
    list= []; #Define list.
    for a in range(0, n):
        list.append(a) 
        print(a*a);

if __name__ == '__main__':
    n = int(input())
    for a in range(0, n):
        print(a*a);


def is_leap(year):
    leap = False
    # Write your logic here
    if year%4==0:
        leap= True;
        if year%100:
            leap= False;
            if year%400:
                leap= True;
    return leap
year = int(input())

My Answer- 

def is_leap(year):
    leap = False
    # Write your logic here
    if year%4==0:
        leap= True;
        if year%100==0:
            leap= False;
            if year%400==0:
                leap= True;
    return leap
year = int(input())

____________________

    PreparePythonIntroductionPrint Function

Print Function


from __future__ import print_function

if __name__ == '__main__':
    n = int(raw_input())
    for a in range(1, n+1):
        print(a , end ='' );

__________________

    PreparePythonRegex and ParsingGroup(), Groups() & Groupdict()

Group(), Groups() & Groupdict()

import re
if __name__ == '__main__':
    S = input()
    #print (S);
    out= re.findall("+", S)
    print(out);
    #x = re.findall(".+", S)

Discussion answer- 

import re
m = re.search(r'([a-zA-Z0-9])\1+', input().strip())    # Also could use (\w(?!_))\1+ as the regular expression. 
print(m.group(1) if m else -1)

_____________________


    PreparePythonRegex and ParsingRe.findall() & Re.finditer()

Re.findall() & Re.finditer()


import re
m = re.search(r'([a-zA-Z0-9])\1+', input().strip())    # Also could use (\w(?!_))\1+ as the regular expression. 
print(m.group(1) if m else -1)

Discussion answers-

import re
s = '[qwrtypsdfghjklzxcvbnm]'
a = re.findall('(?<=' + s +')([aeiou]{2,})' + s, input(), re.I)
print('\n'.join(a or ['-1']))


?    Causes the resulting RE to match 0 or 1 repetitions of the preceding RE. ab? will match either ‘a’ or ‘ab’.

(?<=...)    Matches if the current position in the string is preceded by a match for ... that ends at the current position. This is called a positive lookbehind assertion. (?<=abc)def will find a match in 'abcdef', since the lookbehind will back up 3 characters and check if the contained pattern matches. The contained pattern must only match strings of some fixed length, meaning that abc or a|b are allowed, but a* and a{3,4} are not. Note that patterns which start with positive lookbehind assertions will not match at the beginning of the string being searched; you will most likely want to use the search() function rather than the match() function:
    >>>import re
m = re.search('(?<=abc)def', 'abcdef')
m.group(0)
'def'
This example looks for a word following a hyphen:
>>>m = re.search(r'(?<=-)\w+', 'spam-egg')
m.group(0)
'egg'


+    Causes the resulting RE to match 1 or more repetitions of the preceding RE. ab+ will match ‘a’ followed by any non-zero number of ‘b’s; it will not match just ‘a’.


match = re.findall(r'(?<=['+consonants+'])(['+vowels+']{2,})(?=['+consonants+'])',raw_input(),flags = re.I)


(?=...)    Matches if ... matches next, but doesn’t consume any of the string. This is called a lookahead assertion. For example, Isaac (?=Asimov) will match 'Isaac ' only if it’s followed by 'Asimov'.

# Enter your code here. Read input from STDIN. Print output to STDOUT
import re
s = '[qwrtypsdfghjklzxcvbnm]'
a = re.findall('(?<=' + s +')([aeiou]{2,})' + s, input(), re.I)
print('\n'.join(a or ['-1']))


Interesting regex answer-

import re
e=re.findall(r'(?<=[^aieou])([aeiou]{2,})(?=[^aieou])', input().strip(), re.I)
print(*e if e!=[] else [-1], sep='\n')

______________________

    PreparePythonRegex and ParsingRe.start() & Re.end()

Re.start() & Re.end()

import re
S = input()
k = input()
m = re.search(r'(?<=k)',S)
m.end();
m.start();
print(m.end(), m.start());

Discussion answer-

import re
s = input()
k = input()
index = 0
if re.search(k, s):
    while index+len(k) < len(s):
        m = re.search(k, s[index:]) #begins search with new index
        print("({0}, {1})".format(index+m.start(), index+m.end()-1)) 
        index += m.start() + 1 #assign new index by +1 
else:
    print((-1, -1))

import re
s = input()
print (s);
k = input()
print (k);
if (input()):
    l = input()
    print (l);
else:
    print('No further inputs');


import re
s = input()
print (s);
k = input()
print (k);
m = re.search(r'(?<='+ k +')',s, );
print(m);
print(m.start());
print(m.end());


import re
text, pattern = input(), input()
m= list(re.finditer("(?=(%s))"%pattern,text))
if not m:
    print((-1,-1))
for i in m:
    print((i.start(1),i.end(1)-1))

________________


    PreparePythonRegex and ParsingRegex Substitution

Regex Substitution


re.sub(r"\d+", square, "1 2 3 4 5 6 7 8 9")

/s/&/&/s 	#I think &, | are escape characters so they need / before them. /s... /s means that spaces are either side of the search term.
/s/|/|/s

or could match ' && ' or ' || '.

import re
string= input();
#for input():
#    string= string+ input();
string= re.sub(r"/s&&/s", " and ", string);
print (string);
string= re.sub(r"/s/|/|/s", " or ", string);
print (string);


import re
print('\n'.join(re.sub(R'(?<= )(&&|\|\|)(?= )', lambda x: 'and' if x.group()=='&&' else 'or', input()) for _ in range(int(input().strip()))))


Discussion answer-

import re
S=int(input())
for i in range(S):
      pattern1=re.compile(r'(?<= )(&&)(?= )')
      pattern2=re.compile(r'(?<= )(\|\|)(?= )')
      print(pattern2.sub('or', pattern1.sub('and', input())))

Tried unsuccessfully-

import re
S=int(input());
T= S;
for i in range(T):
        T= re.sub(r'(?<= )(&&)(?= )', 'and', T);
        #T=re.sub(r'(?<= )(&&)(?= )')
        T= re.sub(r'(?<= )(\|\|)(?= )', 'or', T);
        #T=re.sub(r'(?<= )(\|\|)(?= )')
        print(T);

My answer-

import re
S=int(input());		# Not sure about this line. 
for i in range(S):
      pattern1=re.sub('(?<= )(&&)(?= )', 'and', input())
      pattern2=re.sub('(?<= )(\|\|)(?= )', 'or', pattern1)
      print(pattern2)




________________

    PreparePythonRegex and ParsingValidating Roman Numerals

Validating Roman Numerals


regex_pattern = r""	# Do not delete 'r'.
import re
print(str(bool(re.match(regex_pattern, input()))))

regex_pattern = r""	# Do not delete 'r'.
# Equals M (1000), D (500), C (100), L (50), X (10), V (5), I (1)
import re
print(str(bool(re.match(regex_pattern, input()))))

Discussion Answer-

The engine seems to constrain the answer so you can't add lines etc. So eventually I just put the regex pattern in the quotes. It's a bit cryptic. 

regex_pattern = r"^M{,3}(C(D|M)|D?C{,3})(X(L|C)|L?X{,3})(I(X|V)|(X|V)?I{,3})$"	# Do not delete 'r'.
import re
print(str(bool(re.match(regex_pattern, input()))))



















